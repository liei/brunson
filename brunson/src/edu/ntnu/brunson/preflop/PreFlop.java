package edu.ntnu.brunson.preflop;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintStream;
import java.text.DateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;


import edu.ntnu.brunson.cards.Card;
import edu.ntnu.brunson.cards.Deck;
import edu.ntnu.brunson.cards.Pile;
import edu.ntnu.brunson.cards.Value;
import edu.ntnu.brunson.manager.HandRating;

public class PreFlop {

	private static final int NUM_EQUIVALENCE_CLASSES = Value.values().length * Value.values().length; 
	
	private static final DateFormat DATE_FORMAT = DateFormat.getDateTimeInstance();
	
	private static final ExecutorService service = Executors.newFixedThreadPool(4);
	
	private static Map<String,Double> table = null;
	
	private PreFlop(){}

	public static void main(String[] args) {
		generate(System.out,1000);
	}
	
	public static void generate(PrintStream out,int runs){
		long start = System.currentTimeMillis();

		int numPlayers = 10;
		List<Simulation> sims = new ArrayList<Simulation>();
		for(int players = 2; players <= numPlayers; players++)
			sims.add((new Simulation()).runHands(players,runs));

		
		service.shutdown();
		boolean terminated = false;
		Exception e = null;
		try {
			//Wait a week.
			terminated = service.awaitTermination(7,TimeUnit.DAYS);
		} catch (InterruptedException ie) {
			e = ie;//k
		}
		long stop = System.currentTimeMillis();
		
		out.println("# Preflop Rollout Simulation");
		out.println("# generated by edu.ntnu.brunson.PreFlop.generate()");
		out.printf( "# players: %d, runs: %d%n",numPlayers,runs);
		out.printf( "# generated %s, ",DATE_FORMAT.format(new Date()));
		
		
		if(terminated){
			out.printf("took: %d seconds%n",(stop - start)/1000);
			for(Simulation sim : sims)
				sim.print(out);
		} else {
			out.println("failed to terminate");
			out.println();
			if(e != null)
				e.printStackTrace();
		}
	}
	
	public static String equivClass(Pile hand,int players){
		if(hand.size() != 2)
			throw new IllegalArgumentException("hand must have size 2");
		Card c1 = hand.getCard(0);
		Card c2 = hand.getCard(1);
		boolean suited = c1.getSuit() == c2.getSuit();
		return String.format("%s%s%s-%d",c1.getValue(),c2.getValue(),suited ? "s" : "",players);
	}
	
	public static void load(String filepath) throws IOException{
		table = new HashMap<String,Double>();
		BufferedReader br = null; 

		br = new BufferedReader(new FileReader(filepath));
		String line;
		while((line = br.readLine()) != null){
			String[] toks = line.split(" ");
			table.put(toks[0],Double.parseDouble(toks[1]));
		}
	}
	
	public double get(Pile hand,int players){
		String eqClass = equivClass(hand,players);
		return table.get(eqClass);
	}
	
	static class Simulation {

		HandRun[] handRuns;
		
		public Simulation(){ 
			handRuns = new HandRun[NUM_EQUIVALENCE_CLASSES];
		}

		public Simulation runHands(int players,int runs) {
			int index = 0;
			Value[] values = Value.values();
			for(int i = 0; i < values.length; i++){
				Value v1 = values[i];
			
				Pile pocket = Deck.getPile(String.format("%sc%sh",v1,v1));
				handRuns[index++] = new HandRun(pocket,players,runs);
			
				for(int j = i + 1; j < values.length; j++){
					Value v2 = values[j];
					
					Pile offSuit = Deck.getPile(String.format("%sc%sh",v1,v2));
					handRuns[index++] = new HandRun(offSuit,players,runs);
					
					Pile suited = Deck.getPile(String.format("%sc%sc",v1,v2));
					handRuns[index++] = new HandRun(suited,players,runs);
				}
			}
			return this;
		}
		
		public void print(PrintStream out){
			Arrays.sort(handRuns);
			for(int i = 0; i < handRuns.length; i++){
				int percentile = ((i + 1) * 100) / NUM_EQUIVALENCE_CLASSES;
				out.printf("%s %d%n",handRuns[i].equiv(),percentile);
			}
		}
	}

	static class HandRun implements Runnable,Comparable<HandRun>{

		Pile myHand;
		int players;
		int runs;
		int wins, ties;
		
		public HandRun(Pile hand, int players, int runs) {
			myHand = hand;
			this.players = players;
			this.runs = runs;
			service.submit(this);
		}

		public String equiv() {
			return equivClass(myHand,players);
		}

		@Override
		public void run() {
			for(int i = 0; i < runs; i++)
				runHand();
		}
		
		private void runHand() {
			Pile deck = Deck.incompleteDeck(myHand).shuffle();
			Pile community = deck.deal(3);
			boolean tie = false;
			HandRating myRating = HandRating.rate(myHand,community);
			for(int i = 1; i < players; i++){
				HandRating theirRating = HandRating.rate(deck.deal(2),community);
				int comp = myRating.compareTo(theirRating);
				if(comp  < 0){
					return;
				} else if(comp == 0){
					tie = true;
				}
			}
			if(tie) {
				ties++;
			} else {
				wins++;
			}	
		}		
		
		@Override
		public int compareTo(HandRun that) {
			return (this.wins + this.ties/2) - (this.wins + that.ties/2);
		}
	}
}
