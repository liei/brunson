package edu.ntnu.brunson.preflop;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintStream;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.text.DateFormat;
import java.text.ParseException;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;


import edu.ntnu.brunson.cards.Card;
import edu.ntnu.brunson.cards.Deck;
import edu.ntnu.brunson.cards.Pile;
import edu.ntnu.brunson.cards.Value;
import edu.ntnu.brunson.manager.HandRating;

public class PreFlop {

	private static final int NUM_EQUIVALENCE_CLASSES = Value.values().length * Value.values().length; 
	private static final DateFormat DATE_FORMAT = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);

	
	private static ExecutorService service = Executors.newFixedThreadPool(4);
	
	private static HashMap<String, Integer> table = null;
	
	private static int players = -1; 
	
	private PreFlop(){}

	public static void main(String[] args) {
		String filename = "preflop.txt";
//		try {
//			PrintStream out = new PrintStream(new FileOutputStream(filename));
//			generate(out,1000);
//		} catch (FileNotFoundException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		try {
			load(filename);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		Pile[] piles = new Pile[3];
		piles[0] = Deck.getPile("AsAh");
		piles[1] = Deck.getPile("4hKs");
		piles[2] = Deck.getPile("4hKh");
		for(Pile pile : piles){
			System.out.printf("%s:",pile);
			for(int i = 2; i <= 10; i++)
				System.out.printf(" %d",get(pile,i));
			System.out.println();
			
			
		}
	}
	
	public static void generate(PrintStream out,int runs){
		long start = System.currentTimeMillis();

		int numPlayers = 10;
		List<Simulation> sims = new ArrayList<Simulation>();
		for(int players = 2; players <= numPlayers; players++)
			sims.add((new Simulation()).runHands(players,runs));

		
		service.shutdown();
		boolean terminated = false;
		Exception e = null;
		try {
			//Wait a week.
			terminated = service.awaitTermination(7,TimeUnit.DAYS);
		} catch (InterruptedException ie) {
			e = ie;//k
		}
		long stop = System.currentTimeMillis();
		
		String hostname = "";
		try {
			hostname = InetAddress.getLocalHost().getHostName();
		} catch (UnknownHostException uhe) {
			hostname = "unknown";
		}
		
		out.println("# Preflop Rollout Simulation");
		out.println("# generated by edu.ntnu.brunson.PreFlop.generate()");
		out.printf( "# players: %d, runs: %d%n",numPlayers,runs);
		out.printf( "# generated @ %s, %s, ",hostname,DATE_FORMAT.format(new Date()));
		
		
		if(terminated){
			out.printf("took: %d seconds%n",(stop - start)/1000);
			for(Simulation sim : sims)
				sim.print(out);
		} else {
			out.println("failed to terminate");
			out.println();
			if(e != null)
				e.printStackTrace();
		}
	}
	
	private static String findEquivClass(Pile hand,int players){
		if(hand.size() != 2)
			throw new IllegalArgumentException("hand must have size 2");
		Card c1 = hand.getCard(0);
		Card c2 = hand.getCard(1);
		boolean suited = c1.getSuit() == c2.getSuit();
		return String.format("%d-%s%s%s",players,c1.getValue(),c2.getValue(),suited ? "s" : "");
	}
	
	public static void load(String filepath) throws IOException, ParseException{
		table = new HashMap<String,Integer>();
		BufferedReader br = null; 

		br = new BufferedReader(new FileReader(filepath));
		String line;
		int lineno = 1;
		while((line = br.readLine()) != null){
			if(line.length() > 0 && line.charAt(0) != '#'){
				String[] toks = line.split(" ");
				if(toks.length != 2)
					throw new ParseException(line, lineno);
				table.put(toks[0],Integer.parseInt(toks[1]));
			}
			lineno++;
		}
	}
	
	public static int get(Pile hand,int players){
		String eqClass = findEquivClass(hand,players);
		return table.get(eqClass);
	}
	
	public static boolean inPercentile(Pile hand, int percentile){
		if(players == -1)
			throw new IllegalStateException("PreFlop.setPlayers() must be called.");
		return get(hand,players) >= percentile;
	}
	
	static class Simulation {

		HandRun[] handRuns;
		
		public Simulation(){ 
			handRuns = new HandRun[NUM_EQUIVALENCE_CLASSES];
		}

		public Simulation runHands(int players,int runs) {
			int index = 0;
			Value[] values = Value.values();
			for(int i = 0; i < values.length; i++){
				Value v1 = values[i];
			
				Pile pocket = Deck.getPile(String.format("%sc%sh",v1,v1));
				handRuns[index++] = new HandRun(pocket,players,runs);
			
				for(int j = i + 1; j < values.length; j++){
					Value v2 = values[j];
					
					Pile offSuit = Deck.getPile(String.format("%sc%sh",v1,v2));
					handRuns[index++] = new HandRun(offSuit,players,runs);
					
					Pile suited = Deck.getPile(String.format("%sc%sc",v1,v2));
					handRuns[index++] = new HandRun(suited,players,runs);
				}
			}
			return this;
		}
		
		public void print(PrintStream out){
			Arrays.sort(handRuns);
			for(int i = 0; i < handRuns.length; i++){
				int percentile = ((i + 1) * 100) / NUM_EQUIVALENCE_CLASSES;
				out.printf("%s %d%n",handRuns[i].equiv(),percentile);
			}
		}
	}

	static class HandRun implements Runnable,Comparable<HandRun>{

		Pile myHand;
		int players;
		int runs;
		int wins, ties;
		
		public HandRun(Pile hand, int players, int runs) {
			myHand = hand;
			this.players = players;
			this.runs = runs;
			service.submit(this);
		}

		public String equiv() {
			return findEquivClass(myHand,players);
		}

		@Override
		public void run() {
			for(int i = 0; i < runs; i++)
				runHand();
		}
		
		private void runHand() {
			Pile deck = Deck.incompleteDeck(myHand).shuffle();
			Pile community = deck.deal(3);
			boolean tie = false;
			HandRating myRating = HandRating.rate(myHand,community);
			for(int i = 1; i < players; i++){
				HandRating theirRating = HandRating.rate(deck.deal(2),community);
				int comp = myRating.compareTo(theirRating);
				if(comp  < 0){
					return;
				} else if(comp == 0){
					tie = true;
				}
			}
			if(tie) {
				ties++;
			} else {
				wins++;
			}	
		}		
		
		@Override
		public int compareTo(HandRun that) {
			return (this.wins + this.ties/2) - (that.wins + that.ties/2);
		}
	}
}
