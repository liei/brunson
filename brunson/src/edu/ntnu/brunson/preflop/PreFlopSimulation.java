package edu.ntnu.brunson.preflop;

import java.io.PrintStream;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.text.DateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import edu.ntnu.brunson.cards.Deck;
import edu.ntnu.brunson.cards.Pile;
import edu.ntnu.brunson.cards.Value;
import edu.ntnu.brunson.manager.HandRating;

public class PreFlopSimulation {

	private static final int NUM_EQUIVALENCE_CLASSES = Value.values().length * Value.values().length; 
	private static final DateFormat DATE_FORMAT = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);

	private static ExecutorService service;
	
	private PreFlopSimulation(){}

	public static void main(String[] args) {
		generate(System.out,10,2,100,4);
	}
	
	public static void generate(PrintStream out, int maxPlayers, int timeout, int runs, int threads) {

		service = Executors.newFixedThreadPool(threads);
		
		long start = System.currentTimeMillis();

		List<Simulation> sims = new ArrayList<Simulation>();
		for(int players = 2; players <= maxPlayers; players++)
			sims.add((new Simulation(players)).runHands(runs));

		
		service.shutdown();
		boolean terminated = false;
		Exception e = null;
		try {
			terminated = service.awaitTermination(timeout,TimeUnit.HOURS);
		} catch (InterruptedException ie) {
			e = ie;
		}
		long stop = System.currentTimeMillis();
		
		String hostname = "";
		try {
			hostname = InetAddress.getLocalHost().getHostName();
		} catch (UnknownHostException uhe) {
			hostname = "unknown";
		}
		
		out.println("# Preflop Rollout Simulation");
		out.println("# generated by edu.ntnu.brunson.PreFlop.generate()");
		out.printf( "# max players: %d, runs: %d%n",maxPlayers,runs);
		out.printf( "# generated @ %s, %s, ",hostname,DATE_FORMAT.format(new Date()));
		
		if(terminated){
			out.printf("took: %d seconds%n",(stop - start)/1000);
			out.println("# <players>|{<hand>:<percentile>}");
			for(Simulation sim : sims)
				sim.print(out);
		} else {
			out.println("failed to terminate");
			out.println();
			if(e != null)
				e.printStackTrace();
		}
	}
			
	static class Simulation {

		private int players;
		private HandRun[] handRuns;
		
		public Simulation(int players){
			this.players = players;
			handRuns = new HandRun[NUM_EQUIVALENCE_CLASSES];
		}

		public Simulation runHands(int runs) {
			int index = 0;
			Value[] values = Value.values();
			for(int i = 0; i < values.length; i++){
				Value v1 = values[i];
			
				Pile pocket = Deck.getPile(String.format("%sc%sh",v1,v1));
				handRuns[index++] = new HandRun(pocket,players,runs);
			
				for(int j = i + 1; j < values.length; j++){
					Value v2 = values[j];
					
					Pile offSuit = Deck.getPile(String.format("%sc%sh",v1,v2));
					handRuns[index++] = new HandRun(offSuit,players,runs);
					
					Pile suited = Deck.getPile(String.format("%sc%sc",v1,v2));
					handRuns[index++] = new HandRun(suited,players,runs);
				}
			}
			return this;
		}
		
		public void print(PrintStream out){
			Arrays.sort(handRuns);
			out.printf("%d|",players);
			for(int i = 0; i < handRuns.length; i++){
				int percentile = ((i + 1) * 100) / NUM_EQUIVALENCE_CLASSES;
				out.printf("%s:%d ",handRuns[i],percentile);
			}
			out.println();
		}
	}

	static class HandRun implements Runnable,Comparable<HandRun>{

		Pile myHand;
		int players;
		int runs;
		int wins, ties;
		
		public HandRun(Pile hand, int players, int runs) {
			myHand = hand;
			this.players = players;
			this.runs = runs;
			service.submit(this);
		}

		@Override
		public void run() {
			for(int i = 0; i < runs; i++)
				runHand();
		}
		
		private void runHand() {
			Pile deck = Deck.incompleteDeck(myHand).shuffle();
			Pile community = deck.deal(3);
			boolean tie = false;
			HandRating myRating = HandRating.rate(myHand,community);
			for(int i = 1; i < players; i++){
				HandRating theirRating = HandRating.rate(deck.deal(2),community);
				int comp = myRating.compareTo(theirRating);
				if(comp  < 0){
					return;
				} else if(comp == 0){
					tie = true;
				}
			}
			if(tie) {
				ties++;
			} else {
				wins++;
			}	
		}		
		
		@Override
		public int compareTo(HandRun that) {
			return (this.wins + this.ties/2) - (that.wins + that.ties/2);
		}
		
		public String toString(){
			return PreFlopTable.equivClass(myHand);
		}
	}
}
